NumPy stands for Numerical Python.
It provides powerful tools for fast numerical computing using arrays, matrices, and vectorized operations.


<!-- Why Do Data Scientists Use NumPy? -->
* Fast math on big data: Vectorized operations are super fast
* Handling arrays/matrices: 2D, 3D, nD data made simple 
* Underlying engine: Powers Pandas, SciPy, Scikit-learn 
* Scientific computing: Essential for simulations, ML, stats


<!-- 1. Creating Arrays -->
import numpy as np

a = np.array([1, 2, 3])              # 1D array
b = np.array([[1, 2], [3, 4]])       # 2D array
np.zeros((2, 3))                     # 2x3 array of 0s
np.ones((3, 3))                      # 3x3 array of 1s
np.eye(4)                            # 4x4 Identity matrix
np.arange(0, 10, 2)                  # [0 2 4 6 8]
np.linspace(0, 1, 5)                 # Evenly spaced numbers
np.full((2, 2), 5)                   # Filled with 5s


<!-- 2. Inspecting Arrays -->
a.shape        # dimensions (rows, columns)
a.ndim         # number of dimensions
a.size         # total number of elements
a.dtype        # data type of elements
arr.itemsize   # size of each item in bytes


<!-- 3. Array Operations -->
a + b        
a - b
a * b
a / b
np.dot(a, b)   # matrix multiplication


<!-- 4. Stats and Math -->
a.sum(), a.mean(), a.std(), a.min(), a.max()
np.sqrt(a)
np.exp(a)
np.log(a)


arr + 2, arr * 3     # broadcasting
arr.sum()
arr.mean()
arr.std()
arr.min(), arr.max()
np.sqrt(arr)
np.exp(arr)
np.log(arr)
np.dot(A, B)         # matrix multiplication



<!-- 5. Reshaping and Stacking -->
a.reshape((3, 2))           # reshape array
np.concatenate([a, b], axis=0)  # stack rows
np.vstack([a, b])                # vertical
np.hstack([a, b])                # horizontal

arr.reshape((3, 2))          # reshape to 3x2
arr.flatten()                # 1D version
arr.T                        # transpose


np.vstack([a, b])            # vertical stack
np.hstack([a, b])            # horizontal stack
np.concatenate([a, b])       # concat by axis


<!-- 6. Indexing & Slicing -->
a[0], a[1:3], a[-1]
a[1, 2]                      # access row 1, col 2
a[:, 0]                      # first column
a[0, :]                      # first row

<!-- 7. Boolean Filtering -->
a[a > 5]             # elements greater than 5
a[(a > 2) & (a < 6)] # multiple conditions

<!-- 8. Random & Simulation -->
np.random.rand(3, 2)         # uniform [0,1)
np.random.randn(3, 2)        # normal distribution
np.random.randint(0, 10, size=(2, 2))  # random ints
np.random.seed(42)           # reproducibility


9. Missing Data (NaN Handling)
np.isnan(arr)
arr[~np.isnan(arr)]               # remove NaNs
np.nanmean(arr)                   # mean ignoring NaN


10. Advanced
np.where(arr > 5, 1, 0)        # conditional replace
np.unique(arr)                 # unique values
np.sort(arr)                   # sort array
np.argsort(arr)                # get sort indices
np.cumsum(arr)                 # cumulative sum
np.clip(arr, 0, 10)            # clip values


11. File I/O
np.save('my_array.npy', arr)      # save binary
np.load('my_array.npy')           # load binary
np.savetxt('data.csv', arr, delimiter=',')
np.loadtxt('data.csv', delimiter=',')


<!-- Broadcasting in NumPy -->
Broadcasting lets NumPy perform operations between arrays of different shapes by automatically expanding dimensions when it makes sense.

import numpy as np

a = np.array([1, 2, 3])      # shape: (3,)
b = 2                        # shape: () — scalar

print(a + b)  # [3 4 5]

Even though b is a scalar (shape ()), NumPy broadcasts it to match the shape of a → [2, 2, 2].


Broadcasting Rules (Simplified)
Compare array shapes from right to left.

Two dimensions are compatible when:

They are equal, OR

One of them is 1

If compatible, NumPy stretches (broadcasts) the smaller array.


<!-- Aggregate Function -->
An aggregate function takes multiple values and reduces them to a single summary value.

✅ It's like summarizing a column or row in a dataset.